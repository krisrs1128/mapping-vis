{
  "articles": [
    {
      "path": "1-preview.html",
      "title": "A First Look",
      "description": "An initial look at the raw data, with an eye towards preprocessing.\n",
      "author": [
        {
          "name": "Kris Sankaran",
          "url": {}
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\nIn this notebook, we take a first look at the glacier data. We’ll download the raw annotations and images, using visualization to gain familiarity with the structure of the problem.\nWe’ll be using the R packages below. dplyr, ggplot2, and tidyr are part of R’s tidy data ecosystem. gdalutils, raster, and sf are packages for general spatial data manipulation. RStoolbox gives useful functions for spatial data visualization specifically.\n\n\nlibrary(\"RStoolbox\")\nlibrary(\"dplyr\")\nlibrary(\"gdalUtils\")\nlibrary(\"ggplot2\")\nlibrary(\"raster\")\nlibrary(\"readr\")\nlibrary(\"sf\")\nlibrary(\"tidyr\")\nsource(\"data.R\")\ntheme_set(theme_bw())\n\n\n\nIn the block below, we’ll create a directory structure to store the data in our analysis. If you’re working on your own computer, you can change the directory to which files are written by modifying the params block in the header of this rmarkdown file.\n\n\ndata_dir <- params$data_dir\ndir.create(params$data_dir, recursive = TRUE)\n\n\n\nNext, we download the actual imagery. The data are currently stored on a UW Madison Box folder. We first download a file containing all the raw data links1, and then loop over just those links. This step can take some time, because the files are relatively large.\n\n\n# download all linked data\ndata_links <- read_csv(params$data_links) %>%\n  filter(download)\n\nfor (i in seq_len(nrow(data_links))) {\n  download.file(\n    data_links$link[i], \n    file.path(data_dir, data_links$name[i])\n  )\n}\n\n\n\nOften, we’ll want to find the image associated with a particular point on the earth. In the current form, this is quite hard to do: we’d have to check image by image, until we found the one that had the geographic coordinate that we’re looking for. A much more convenient format is something called a ``Virtual Tiff.’’ This indexes all the imagery we had originally downloaded, letting us look up imagery just by specifying the geographic coordinates. This means we can hide all the complexity of working with many imagery files and pretend we had a single (very large) image.\n\n\nx_paths <- dir(data_dir, \"*tiff\", full.names = TRUE)\nvrt_path <- file.path(data_dir, \"region.vrt\")\ngdalbuildvrt(x_paths, vrt_path, ot=\"float64\")\n\n\nNULL\n\nTime for our first visualization! The glaciers.geojson file demarcates the boundaries for two types of glaciers that are common in the Hindu Kush Himalayas region. The full dataset gives coordinates for glaciers across the whole region, which spans many countries, making it a bit overwhelming to visualize. Instead, let’s pick one of 63 basins in the region and visualize its glacier boundaries.\n\n\ny <- read_sf(file.path(data_dir, \"glaciers.geojson\")) %>%\n  filter(Sub_basin == \"Dudh Koshi\")\nhead(y)\n\n\nSimple feature collection with 6 features and 20 fields\ngeometry type:  MULTIPOLYGON\ndimension:      XY\nbbox:           xmin: 86.53224 ymin: 27.90988 xmax: 86.89739 ymax: 28.06725\ngeographic CRS: WGS 84\n# A tibble: 6 x 21\n     ID Longitude Latitude GLIMS_ID Glaciers Elv_min Elv_mean Elv_max\n  <int>     <dbl>    <dbl> <chr>    <chr>      <int>    <int>   <int>\n1    75      86.6     28.0 G086626… Debris …    4938     5200    5684\n2   106      86.7     28.0 G086700… Debris …    4691     5053    5996\n3   131      86.8     28.0 G086799… Debris …    4982     5053    5299\n4    60      86.6     28.0 G086565… Debris …    4849     4970    5192\n5   148      86.9     27.9 G086866… Debris …    4970     5232    5582\n6   149      86.9     27.9 G086889… Debris …    4979     5098    5288\n# … with 13 more variables: Slope_min <int>, Slope_mean <int>,\n#   Slope_max <int>, Aspect <int>, Area_SqKm <dbl>, Thickness <dbl>,\n#   Reserve <dbl>, Basin <chr>, M_Basin <chr>, Region <chr>,\n#   Country <chr>, Sub_basin <chr>, geometry <MULTIPOLYGON [°]>\n\n\n\nggplot(y, aes(fill = Glaciers)) +\n  geom_sf() +\n  scale_fill_manual(values = c(\"#93b9c3\", \"#4e326a\")) +\n  theme(legend.position = \"bottom\")\n\n\n\n\nFrom a technical perspective, there are two points worth noting. First, we were able to use dplyr’s filter function on these glaciers, as if they were stored in an ordinary data frame (they’re in fact stored in a spatial data frame). Being able to use concepts of tidy data manipulation in spatial problems can make our lives much easier. Second, notice that we’re using tm_shape from the tmap package – this package makes much nicer spatial data visualizations than simply calling plot() from base R. It also implements a grammar of graphics for spatial data, allowing us to layer on different visual encodings in a flexible way.\nNext, let’s visualize the satellite imagery in that region. The satellite images are not like ordinary images from a camera – they have many sensors. In our case, each pixel is associated with 15 measurements. For example, the block below first plots the RGB colors associated with the region before showing a composite that turns all the glaciers blue.\n\n\nx <- read_subset(vrt_path, st_bbox(y))\nggRGB(x)\n\n\n\nggRGB(x, r = 5, g = 4, b = 2)\n\n\n\n\nNotice the similarities with the outlines in the glaciers.geojson file. We can more or less distinguish the clean ice and debris-covered glaciers from the rest of the image. Looking a bit more carefully, though, we realize that there are lots of areas that fall into the bluish regions but which aren’t labeled as clean ice glacier. We might hope that some of the other channels make the difference more visible, but it seems like there might be some danger of false positives. Also, it seems like the debris-covered glaciers are only a subtley different color from the background – their tendril-like shape is a much better visual clue.\nWe’ve managed to use geom_sf and ggRGB to avoid having to convert the raw data to standard R data frames. There are some situations, however, when it can be useful to make that conversion. The code below provides an example that extracts the slope channel from the satellite image and visualizes it using standard ggplot2. It seems like the debris-covered glaciers are relatively flat.\n\n\nslope <- subset(x, 15) %>%\n  as.data.frame(xy = TRUE)\n\nggplot(slope, aes(x = x, y = y)) +\n  geom_raster(aes(fill = slope)) +\n  scale_fill_gradient(low = \"white\", high = \"black\") +\n  coord_fixed() +\n  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))\n\n\n\nrm(slope) # save space\n\n\n\nLet’s make a few histograms, one for each satellite sensor. From this view, it becomes clear that we’re going to have to preprocess these data before modeling. First, the ranges across sensors can vary substantially. Second, the BQA channels is not actually a sensor measurement – it’s a quality assignment, which is why it takes on so few values.\n\n\nsample_ix <- sample(nrow(x), 100)\nx_df <- x[sample_ix, sample_ix, ] %>% # subset pixels\n  as.data.frame()\nx_longer <- x_df %>%\n  pivot_longer(cols = everything())\n\nggplot(x_longer) +\n  geom_histogram(aes(x = value)) +\n  facet_wrap(~ name, scale = \"free_x\")\n\n\n\n\nFor our final view, let’s make a scatterplot of a few channels against one another. We’ll bin using geom_hex, because otherwise the points overlap too much. This visualization makes it clear how the two B6 channels are nearly copies of one another, so we can safely drop one of them from our visualization. For reference, we also plot the first two channels, B1 and B2, against one another.\n\n\nggplot(x_df, aes(x = B6_VCID_1, y = B6_VCID_2, fill = log(..count..))) +\n  geom_hex(binwidth = 2) +\n  scale_fill_viridis_c() +\n  coord_fixed()\n\n\n\nggplot(x_df %>% filter(B1 != 255, B2 != 255), aes(x = B1, y = B2, fill = log(..count..))) +\n  geom_hex(binwidth = 2) +\n  scale_fill_viridis_c() +\n  coord_fixed()\n\n\n\n\nWe haven’t made too many plots, but we’ve already gained some valuable intuition about (i) the types of visual features that might be useful for identifying the two types of glaciers and (ii) some properties of the data that, if not properly accounted for, could be disastrous for any downstream modeling (no matter how fancy the model).\n\nIt’s very meta.↩︎\n",
      "last_modified": "2021-02-11T12:03:49-06:00"
    },
    {
      "path": "1b-split.html",
      "title": "Split Basins",
      "description": "Splitting basins into train and test.\n",
      "author": [
        {
          "name": "Kris Sankaran",
          "url": {}
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\n\n\n\n\n\n\nThere are 63 basins total. We randomly assign 45 to train and 18 to test. We manually place Dudh koshi in test, because this is an area we’re independently interested in.\n\n# A tibble: 63 x 2\n   Sub_basin       n\n   <chr>       <int>\n 1 Shyok        3374\n 2 Upper Indus  2248\n 3 Chenab       2167\n 4 Wakhan       2129\n 5 Satluj       1522\n 6 Hunza        1446\n 7 Kunar        1233\n 8 Zanskar      1229\n 9 Kokcha       1061\n10 Gilgit       1037\n# … with 53 more rows\n\n\n [1] \"Alin-Alis-Nur\" \"Astor\"         \"Bhagirathi\"    \"Bheri\"        \n [5] \"Bhilanga\"      \"Budi Gandaki\"  \"Chenab\"        \"Dangme Chu\"   \n [9] \"Dibhang\"       \"East Rathong\"  \"Gilgit\"        \"Humla\"        \n[13] \"Hunza\"         \"Jhelum\"        \"Kali\"          \"Kali Gandaki\" \n[17] \"Kameng\"        \"Kawari\"        \"Kunar\"         \"Kuri Chu\"     \n[21] \"Likhu\"         \"Lohit\"         \"Mandakini\"     \"Mangde Chu\"   \n[25] \"Marsyangdi\"    \"Mo Chu\"        \"Pengong\"       \"Pindar\"       \n[29] \"Ravi\"          \"Seti\"          \"Shigar\"        \"Shyok\"        \n[33] \"Subansiri\"     \"Sun Koshi\"     \"Surkhab\"       \"Swat\"         \n[37] \"Tama Koshi\"    \"Tamor\"         \"Tila\"          \"Tons\"         \n[41] \"Upper Indus\"   \"Wakhan\"        \"Zanskar\"       \"Zemu\"         \n [1] \"Alaknanda\"    \"Arun\"         \"Beas\"         \"Chamkhar Chu\"\n [5] \"Changme\"      \"Dudh Koshi\"   \"Indrawati\"    \"Irrawaddy\"   \n [9] \"Kokcha\"       \"Mugu\"         \"Pan-Ghor\"     \"Pho Chu\"     \n[13] \"Satluj\"       \"Shingo\"       \"Talung\"       \"Trishuli\"    \n[17] \"Wang Chu\"     \"West Seti\"    \"Yamuna\"      \n\n\n\n\n\n\n\n",
      "last_modified": "2021-02-11T12:03:50-06:00"
    },
    {
      "path": "2-preprocess.html",
      "title": "Data Preparation",
      "description": "Generating data for model training.\n",
      "author": [
        {
          "name": "Kris Sankaran",
          "url": {}
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\nIn these notes, we generate and visualize patches of data that will be used to train the mapping model. This is necessary for a few different reasons,\nPreprocessing: The different channels need to be normalized, since they have such different ranges. There are also a few channels that we should drop, like the BQA quality channel we saw earlier.\nImbalance: The glaciers only make up a relatively fraction of the total area that we have imagery for. Our model can be trained more efficiently by zooming into the parts of the region that actually have glaciers.\nImage size: Even if we completed these preprocessing steps, each satellite image is much larger than anything a machine learning algorithm could work with. We’ll need to break the processed imagery into pieces that can be sequentially streamed in for training the model1\nWe load quite a few libraries for this step. Many will be familiar from the previous notes, but two new ones are abind, which is used to manipulate subsetted arrays of imagery, and reticulate, which is used to navigate back and forth between R and python. We need reticulate because we will save our final dataset as a collection of .npy numpy files – these are a convenient format for training our mapping model, which is written in python.\n\n\n\nWe want to make sure we don’t overfit our model. To this end, we’ll use different geographic sub-basins for training and evaluation. For training, we’re just using the Kokcha basin, and for evaluation, we use Dudh Koshi. In general, our notebook takes arbitrary lists of basins, specified by links to csv files through the basins parameter in the header. A larger list of training basins was used to train a model we’ll see soon, but it takes much longer to preprocess, and would be a hassle even just to download.\n\n\n\nTo address the imbalance and image size issues, we’ll sample locations randomly from within the current basins’ glaciers. This is done using the st_sample function. More patches will translate into more patches for training the model, but it will also increase the chance that training patches overlap. You will see a warning message about st_intersection – it’s safe to ignore that for our purpose (we are ignoring the fact that the surface of the earth is slightly curved).\n\n\n\nTo better understand this sampling procedure, let’s visualize the centers of the sampled locations on top of the basins that are available for training. We can see that we have more samples in areas that have higher glacier density, which helps alleviate the imbalance problem. As an aside, this visualization gives an example of visualizing a spatial geometry (the glaciers object, y) together with an ordinary data frame (the centers for sampling).\n\n\n\nThat image is quite zoomed out. To see some of the sampling locations along with just a few glaciers, we can zoom in, using the coord_sf modifier.\n\n\n\nNow that we know where we want to sample our training imagery, let’s extract a patch. This is hidden away in generate_patch in the data.R script accompanying this notebook. This function also does all the preprocessing that we mentioned in the introduction. We’ll see the effect of this preprocessing in a minute – for now, let’s just run the patch extraction code. Note that we simultaneously extract a corresponding label, stored in patch_y. It’s these preprocessed satellite imagery - glacier label pairs that we’ll be showing to our model in order to train it.\n\n\n\nLet’s take a look at the preprocessed patches, just as a sanity check. We’re plotting the first of the sampled patches below. The image is much smaller now, but still contains a fair amount of glacier. Notice the false negative debris-covered glacier along the top of the image! A more sophisticated model would account for these kinds of data-specific variations, which become obvious when you visualize the data, but which are otherwise very hard to recognize.\n\n\n\nThe other major change in these preprocessed images is that we’ve applied a quantile transform to each channel, mapping the sensor measurements to between \\(\\left[-1, 1\\right]\\) for every image. We’re using the same histogram code that we used in the first notebook.\n\n\n\nNow that we’ve checked one of the patches, we can write them all to numpy arrays. Even after subsetting to only one basin, this step takes a fair bit of time, so we’ll instead just refer to training and test patches that I generated earlier. We’ll be downloading them at the start of the next notebook, which uses these data to train a mapping model. If you’re curious, we’ve also generated patches using a large list of training basins, available here. Using this larger dataset leads to a noticeably better model, but makes for an unwieldy tutorial. Nonetheless, the data are available for your experimentation after the workshop.\n\n\n\n\nFor reference, the ImageNet dataset, which is a standard benchmark for computer vision problems, most images are usually cropped to 256 \\(\\times\\) 256 pixels.↩︎\n",
      "last_modified": "2021-02-11T12:03:50-06:00"
    },
    {
      "path": "5-eval.html",
      "title": "Analyzing Predictions",
      "description": "Studying saved predictions from a model.\n",
      "author": [
        {
          "name": "Kris Sankaran",
          "url": {}
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\nIn these notes, we’ll visualize some of the predictions from our trained model. Our focus is on the form and quality of the predictions, rather than the mechanics of the training process itself.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# A tibble: 201 x 4\n# Groups:   i [67]\n       i class avg_precision avg_recall\n   <int> <int>         <dbl>      <dbl>\n 1     9     1         0.837      0.363\n 2    29     1         0.797      0.537\n 3    19     1         0.792      0.333\n 4     6     1         0.790      0.551\n 5    66     1         0.776      0.536\n 6    37     1         0.766      0.335\n 7    21     1         0.751      0.279\n 8    32     1         0.744      0.506\n 9    30     1         0.741      0.463\n10    59     1         0.738      0.458\n# … with 191 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "last_modified": "2021-02-11T12:03:51-06:00"
    },
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\n\n\n\n",
      "last_modified": "2021-02-11T12:03:51-06:00"
    },
    {
      "path": "index.html",
      "title": "Visualizing Mapping Models",
      "description": "Data Science Bazaar Workshop <br/>\nFebruary 17, 2021\n",
      "author": [],
      "contents": "\n\nThis workshop explores the role of visualization in data science workflows that use satellite imagery. We’ll get hands-on experience with how visualization can support,\nData validation and cleaning\nModel inspection and error analysis.\nWe’ll walk through a toy version of a glacier mapping problem. Using freely available Landsat imagery, we’ll train a model to recognize different types of glaciers. You are encouraged to bring problems of your own for group discussion.\nPrerequisites\nBasic familiarity with R\nYou should be able to enter the binder notebooks linked below\nSchedule\nThis workshop will be held on February 17, 2021.\nTime\nFormat\nTopic\n2:45 - 2:55pm\nLecture\nVisualization and ambiguity\n2:55 - 3:35pm\nInteractive Coding\nExploring and developing models\n3:35 - 3:45pm\nDiscussion\nReflections\n3:45 - 3:50pm\nBreak\n\n3:45 - 4:35pm\nInteractive Coding\nExamining the trained models\n4:35 - 4:45pm\nDiscussion\nReflections\nResources\nIntroduction to Data Science: Chapter 7\nR for Data Science: Chapter 12\nGeographic Data in R: Chapter 2\nSpatial Data Science with R\nTowards better analysis of machine learning models: A visual analytics perspective\nContact\nDo you have any questions about the workshop? Don’t hesitate to reach out to ksankaran@wisc.edu.\n\n\n\n",
      "last_modified": "2021-02-11T12:03:51-06:00"
    },
    {
      "path": "workshop.html",
      "title": "Materials",
      "description": "Data Science Bazaar Workshop <br/>\nFebruary 17, 2021\n",
      "author": [],
      "contents": "\nFollow Along\nRstudio\nJupyterlab\nGithub\nCompiled Notes\nData Preview\nPreprocess\nTrain\nSave\nEvaluate\nOther\nIntroductory slides\nDiscussion prompts\nDatasets\n\n\n\n",
      "last_modified": "2021-02-11T12:03:52-06:00"
    }
  ],
  "collections": []
}
